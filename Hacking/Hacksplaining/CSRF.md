# Cross-Site Request Forgery (CSRF)
[https://www.hacksplaining.com/exercises/csrf]

<!-- TOC -->

- [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery-csrf)
    - [Definition](#definition)
    - [An example:](#an-example)
    - [Protection](#protection)
        - [Recommendations](#recommendations)
            - [Anti-CSRF tokens](#anti-csrf-tokens)
            - [SameSite Cookie attribute](#samesite-cookie-attribute)
            - [Additional authentication for sensitive actions](#additional-authentication-for-sensitive-actions)

<!-- /TOC -->

**Classification:**
- Prevalence: Common +++
- Exploitability: Easy +++
- Impact: Harmful ++

## Definition
If an attacker can forge HTTP requests to your site, they may be able to trick your users into triggering unintended actions. The attacker tricks the user into interacting with a page or script on a 3rd party site that generates a malicious request to the target site. All the target side server sees is an HTTP request from an authenticated user.

When coding a web application, it usually works with client-side code (that runs on the user’s browser) and it interacts with the server-side code (backend) which has URL’s that respond to client actions. *Requests to the backend can originate from anywhere* not just the client that was created for that system.

## An example:
* You run a micro-blogging service that allows your users to tweep their opinions with a limit of 149-character-sized chunks.
* Mal is a hacker who notices posts on your service are crafted using HTTP GET requests. This means that all the information required to do a post is carried in the URL of the HTTP request. QUESTION: Does that mean that any POST request is imune to CSRF?
* Mal modifies the post creation URL to include a malicious payload. All he has to do now is to find one of your users to visit this URL form their browser.
```
www.tweeper.com/post?message=This+horse+knows+karate!+www%2Cbit.ly%2F60138Wawd
```
* Mal discovers the email of one of your users and sends him an email with an enticing message.
* User clicks link
* User posts message without even realizing it.
* You now have a worm on your site. Every user that clicks the link will post the same message.

## Protection

* Ensure GET requests are side-effect free;
* Ensure non-GET requests can only be originated from your client-side code.

### Recommendations
Use REST design principles: assign certain types of actions (view, created, delete, update) to different HTTP verbs.

#### Anti-CSRF tokens
Because even non-GET requests being restricted cannot guarantee protection. POST requests can be sent to your site from *scripts* and pages hosted on other domains. Ensure you include a secret and unique token with each response. Have the server check it back in subsequent requests for any non-GET verb.

In short, its purpose is: validating that a request is generated by a page that is connected to the same website.

#### SameSite Cookie attribute
It instructs browsers to control whether cookies are automatically loaded for requests initiated by 3rd party domains (cross-site).
```
Set-Cookie: CookieName=CookieValue; SameSite=Lax;
Set-Cookie: CookieName=CookieValue; SameSite=Strict;
```

*Strict*: any request initiated by a 3rd party domain will have cookies stripped by the browser. NOTE TO SELF: I guess the cross-site origin is determined by the Referer header value and it can be easily manipulated if that’s the case.
*Lax*: GET request get to keep the cookies.

#### Additional authentication for sensitive actions
That’s sometimes a good practice.